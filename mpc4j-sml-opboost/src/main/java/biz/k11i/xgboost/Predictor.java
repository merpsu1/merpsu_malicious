/*
 * Original Work Copyright 2018 H2O.ai.
 * Modified by Weiran Liu. Adjust the code based on Alibaba Java Code Guidelines.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package biz.k11i.xgboost;

import biz.k11i.xgboost.config.PredictorConfiguration;
import biz.k11i.xgboost.fvec.Fvec;
import biz.k11i.xgboost.gbm.GradBoostModel;
import biz.k11i.xgboost.learner.ObjFunction;
import biz.k11i.xgboost.learner.ObjFunctionManager;
import biz.k11i.xgboost.spark.SparkModelParam;
import biz.k11i.xgboost.util.ModelReader;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;

/**
 * Predicts using the XGBoost model.
 *
 * @author KOMIYA Atsushi, KOMIYA Atsushi, Michal Kurka, Weiran Liu
 * @date 2021/10/08
 */
public class Predictor implements Serializable {
    private static final long serialVersionUID = -5397062830428346193L;
    /**
     * base score
     */
    private final float baseScore;
    /**
     * model param
     */
    private ModelParam modelParam;
    /**
     * spark model param
     */
    private SparkModelParam sparkModelParam;
    /**
     * objective function name
     */
    private String objName;
    /**
     * grad boost model name
     */
    private String gbmName;
    /**
     * objective function
     */
    private ObjFunction objFunction;
    /**
     * gradient booster
     */
    private GradBoostModel gradBoostModel;

    public Predictor(InputStream in) throws IOException {
        this(in, null);
    }

    /**
     * Instantiates with the XGBoost model.
     *
     * @param in            input stream.
     * @param configuration configuration.
     * @throws IOException If an I/O error occurs.
     */
    public Predictor(InputStream in, PredictorConfiguration configuration) throws IOException {
        if (configuration == null) {
            configuration = PredictorConfiguration.DEFAULT;
        }

        ModelReader reader = new ModelReader(in);

        readParam(reader);
        initObjFunction(configuration);
        initObjGbm();

        gradBoostModel.loadModel(configuration, reader, modelParam.pBuffer != 0);

        if (modelParam.majorVersion >= 1) {
            baseScore = objFunction.probToMargin(modelParam.baseScore);
        } else {
            baseScore = modelParam.baseScore;
        }
    }

    void readParam(ModelReader reader) throws IOException {
        byte[] first4Bytes = reader.readByteArray(4);
        byte[] next4Bytes = reader.readByteArray(4);

        float baseScore;
        int numFeature;

        if (first4Bytes[0] == 0x62 && first4Bytes[1] == 0x69 && first4Bytes[2] == 0x6e && first4Bytes[3] == 0x66) {

            // Old model file format has a signature "binf" (62 69 6e 66)
            baseScore = reader.asFloat(next4Bytes);
            numFeature = reader.readUnsignedInt();

        } else if (first4Bytes[0] == 0x00 &&
            first4Bytes[1] == 0x05 &&
            first4Bytes[2] == 0x5f) {

            // Model generated by xgboost4j-spark?
            String modelType = null;
            if (first4Bytes[3] == 0x63 &&
                next4Bytes[0] == 0x6c &&
                next4Bytes[1] == 0x73 &&
                next4Bytes[2] == 0x5f) {
                // classification model
                modelType = SparkModelParam.MODEL_TYPE_CLS;

            } else if (first4Bytes[3] == 0x72 &&
                next4Bytes[0] == 0x65 &&
                next4Bytes[1] == 0x67 &&
                next4Bytes[2] == 0x5f) {
                // regression model
                modelType = SparkModelParam.MODEL_TYPE_REG;
            }

            if (modelType != null) {
                int len = (next4Bytes[3] << 8) + (reader.readByteAsInt());
                String featuresCol = reader.readUtf(len);

                this.sparkModelParam = new SparkModelParam(modelType, featuresCol, reader);

                baseScore = reader.readFloat();
                numFeature = reader.readUnsignedInt();

            } else {
                baseScore = reader.asFloat(first4Bytes);
                numFeature = reader.asUnsignedInt(next4Bytes);
            }

        } else {
            baseScore = reader.asFloat(first4Bytes);
            numFeature = reader.asUnsignedInt(next4Bytes);
        }

        modelParam = new ModelParam(baseScore, numFeature, reader);

        objName = reader.readString();
        gbmName = reader.readString();
    }

    void initObjFunction(PredictorConfiguration configuration) {
        objFunction = configuration.getObjFunction();

        if (objFunction == null) {
            objFunction = ObjFunctionManager.fromName(objName);
        }
    }

    void initObjGbm() {
        objFunction = ObjFunctionManager.fromName(objName);
        gradBoostModel = GradBoostModel.Factory.createGradBooster(gbmName);
        gradBoostModel.setNumClass(modelParam.numClass);
        gradBoostModel.setNumFeature(modelParam.featureNum);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat feature vector
     * @return prediction values
     */
    public float[] predict(Fvec feat) {
        return predict(feat, false);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat         feature vector.
     * @param outputMargin whether to only predict margin value instead of transformed prediction.
     * @return prediction values.
     */
    public float[] predict(Fvec feat, boolean outputMargin) {
        return predict(feat, outputMargin, 0);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat       feature vector.
     * @param baseMargin predict with base margin for each prediction.
     * @return prediction values.
     */
    public float[] predict(Fvec feat, float baseMargin) {
        return predict(feat, baseMargin, 0);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat         feature vector.
     * @param baseMargin   predict with base margin for each prediction.
     * @param limitTreeNum limit the number of trees used in prediction.
     * @return prediction values.
     */
    public float[] predict(Fvec feat, float baseMargin, int limitTreeNum) {
        float[] preds = predictRaw(feat, baseMargin, limitTreeNum);
        preds = objFunction.predTransform(preds);
        return preds;
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat         feature vector
     * @param outputMargin whether to only predict margin value instead of transformed prediction
     * @param limitTreeNum limit the number of trees used in prediction
     * @return prediction values
     */
    public float[] predict(Fvec feat, boolean outputMargin, int limitTreeNum) {
        float[] preds = predictRaw(feat, baseScore, limitTreeNum);
        if (!outputMargin) {
            preds = objFunction.predTransform(preds);
        }
        return preds;
    }

    float[] predictRaw(Fvec feat, float baseScore, int limitTreeNum) {
        float[] preds = gradBoostModel.predict(feat, limitTreeNum);
        for (int i = 0; i < preds.length; i++) {
            preds[i] += baseScore;
        }
        return preds;
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector.
     * @return prediction value.
     */
    public float predictSingle(Fvec featureVector) {
        return predictSingle(featureVector, false);
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector
     * @param outputMargin  whether to only predict margin value instead of transformed prediction
     * @return prediction value
     */
    public float predictSingle(Fvec featureVector, boolean outputMargin) {
        return predictSingle(featureVector, outputMargin, 0);
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector.
     * @param outputMargin  whether to only predict margin value instead of transformed prediction.
     * @param numTreeLimit  limit the number of trees used in prediction.
     * @return prediction value.
     */
    public float predictSingle(Fvec featureVector, boolean outputMargin, int numTreeLimit) {
        float pred = predictSingleRaw(featureVector, numTreeLimit);
        if (!outputMargin) {
            pred = objFunction.predTransform(pred);
        }
        return pred;
    }

    float predictSingleRaw(Fvec featureVector, int numTreeLimit) {
        return gradBoostModel.predictSingle(featureVector, numTreeLimit) + baseScore;
    }

    /**
     * Predicts leaf index of each tree.
     *
     * @param featureVector feature vector.
     * @return leaf indexes.
     */
    public int[] predictLeaf(Fvec featureVector) {
        return predictLeaf(featureVector, 0);
    }

    /**
     * Predicts leaf index of each tree.
     *
     * @param featureVector feature vector.
     * @param numTreeLimit  limit, 0 for all.
     * @return leaf indexes.
     */
    public int[] predictLeaf(Fvec featureVector, int numTreeLimit) {
        return gradBoostModel.predictLeaf(featureVector, numTreeLimit);
    }

    /**
     * Predicts path to leaf of each tree.
     *
     * @param featureVector feature vector.
     * @return leaf paths.
     */
    public String[] predictLeafPath(Fvec featureVector) {
        return predictLeafPath(featureVector, 0);
    }

    /**
     * Predicts path to leaf of each tree.
     *
     * @param feat         feature vector.
     * @param limitTreeNum limit, 0 for all.
     * @return leaf paths.
     */
    public String[] predictLeafPath(Fvec feat, int limitTreeNum) {
        return gradBoostModel.predictLeafPath(feat, limitTreeNum);
    }

    public SparkModelParam getSparkModelParam() {
        return sparkModelParam;
    }

    /**
     * Returns number of class.
     *
     * @return number of class
     */
    public int getNumClass() {
        return modelParam.numClass;
    }

    /**
     * Parameters.
     */
    static class ModelParam implements Serializable {
        private static final long serialVersionUID = 5299651032520825971L;
        /**
         * global bias
         */
        final float baseScore;
        /**
         * number of features
         */
        final /* unsigned */ int featureNum;
        /**
         * number of class, if it is multi-class classification
         */
        final int numClass;
        /**
         * whether the model itself is saved with pBuffer
         */
        final int pBuffer;
        /**
         * Model contain eval metrics
         */
        final int containEvalMetrics;
        /**
         * the major version of XGBoost.
         */
        final int majorVersion;
        /**
         * the minor version of XGBoost.
         */
        final int minorVersion;
        /**
         * reserved field
         */
        final int[] reserved;

        ModelParam(float baseScore, int featureNum, ModelReader reader) throws IOException {
            this.baseScore = baseScore;
            this.featureNum = featureNum;
            this.numClass = reader.readInt();
            this.pBuffer = reader.readInt();
            this.containEvalMetrics = reader.readInt();
            this.majorVersion = reader.readUnsignedInt();
            this.minorVersion = reader.readUnsignedInt();
            this.reserved = reader.readIntArray(27);
        }
    }

    public GradBoostModel getBooster() {
        return gradBoostModel;
    }

    public String getObjName() {
        return objName;
    }

    public float getBaseScore() {
        return baseScore;
    }

}
